#!/usr/bin/env bash
# WaxOff — Final Mix Loudness Leveler (transparent; no dynamics processing)
# Two-pass EBU R128 loudness normalization with true-peak safety at -1 dBTP.
# Outputs: WAV / MP3 (CBR) / FLAC; 44.1 or 48 kHz; atomic writes; interactive or flags.

set -u
IFS=$'\n\t'
PATH="/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:${PATH}"

PROMPT="${PROMPT:-1}"                 # 1=interactive menus, 0=flags/env only
TARGET_I="${TARGET_I:--18}"           # -18 or -16
TARGET_TP="${TARGET_TP:--1.0}"        # true-peak safety
OUTMODE="${OUTMODE:-both}"            # wav | mp3 | both | flac | wav+flac | all
MP3_BITRATE="${MP3_BITRATE:-160k}"    # 128k | 160k | 192k
FLAC_LEVEL="${FLAC_LEVEL:-8}"         # 0..12
SAMPLE_RATE="${SAMPLE_RATE:-44100}"   # 44100 | 48000
LOG="${LOG:-${HOME}/Library/Logs/waxoff_cli.log}"
QUIET="${QUIET:-0}"                   # 1 reduces chatter
DRY_RUN="${DRY_RUN:-0}"               # 1 = plan only

TTY_DEV="/dev/tty"; [[ -w "$TTY_DEV" ]] || TTY_DEV="/dev/stdout"
mkdir -p "$(dirname "$LOG")" 2>/dev/null || true

log() { printf '%s\n' "$*" >>"$LOG"; }
say() { [[ "${QUIET}" = "1" ]] && return 0; printf '%s\n' "$*" >"$TTY_DEV"; log "$*"; }
warn() { printf 'Warn: %s\n' "$*" >"$TTY_DEV"; log "Warn: $*"; }
err() { printf 'Error: %s\n' "$*" >"$TTY_DEV" 1>&2; log "Error: $*"; }
die() { err "$*"; exit 1; }
need() { command -v "$1" >/dev/null 2>&1 || die "Missing dependency: $1"; }

log ""
log "======== $(date '+%Y-%m-%d %H:%M:%S') — WaxOff start ========"
log "Args: $*"
log "ENV: PROMPT=$PROMPT TARGET_I=$TARGET_I OUTMODE=$OUTMODE MP3_BITRATE=$MP3_BITRATE FLAC_LEVEL=$FLAC_LEVEL SAMPLE_RATE=$SAMPLE_RATE QUIET=$QUIET DRY_RUN=$DRY_RUN"
command -v ffmpeg >/dev/null 2>&1 && ffmpeg -version | head -n 1 >>"$LOG" 2>&1

# -------------------- Atomic write with format awareness --------------------
atomic_write() {
  local final="$1"; shift
  local fmt="$1"; shift
  [[ "$1" == "--" ]] && shift || true
  local dir base stem ext tmp
  dir="$(dirname "$final")"; base="$(basename "$final")"; ext="${final##*.}"; stem="${base%.*}"
  tmp="${dir}/.${stem}.tmp.$$.$ext"
  [[ "${DRY_RUN}" = "1" ]] && { say "[DRY] ffmpeg ($fmt) -> ${final}"; return 0; }
  mkdir -p "$dir" 2>/dev/null || true
  ffmpeg -hide_banner -nostdin -y -f "$fmt" "$@" "$tmp" >>"$LOG" 2>&1
  local rc=$?
  if [[ $rc -ne 0 ]]; then
    rm -f "$tmp"
    return $rc
  fi
  mv -f "$tmp" "$final"
  return 0
}

# -------------------- loudnorm parsers --------------------
parse_json_loudnorm() {
  awk '
    BEGIN{ I=TP=LRA=TH=OF="" }
    /"input_i"/      { gsub(/[^0-9\.\-]/,"",$2); I=$2 }
    /"input_tp"/     { gsub(/[^0-9\.\-]/,"",$2); TP=$2 }
    /"input_lra"/    { gsub(/[^0-9\.\-]/,"",$2); LRA=$2 }
    /"input_thresh"/ { gsub(/[^0-9\.\-]/,"",$2); TH=$2 }
    /"target_offset"/{ gsub(/[^0-9\.\-]/,"",$2); OF=$2 }
    END{
      if(I==""||TP==""||LRA==""||TH==""||OF=="") exit 1;
      print I,TP,LRA,TH,OF
    }'
}

parse_summary_loudnorm() {
  awk '
    /Input[[:space:]]+Integrated/ { val=$NF; gsub(/[^0-9\.\-]/,"",val); I=val }
    /Input[[:space:]]+True[[:space:]]+Peak/ { val=$NF; gsub(/[^0-9\.\-]/,"",val); TP=val }
    /Input[[:space:]]+LRA/ { val=$NF; gsub(/[^0-9\.\-]/,"",val); LRA=val }
    /Input[[:space:]]+Threshold/ { val=$NF; gsub(/[^0-9\.\-]/,"",val); TH=val }
    /Target[[:space:]]+Offset/ { val=$NF; gsub(/[^0-9\.\-]/,"",val); OF=val }
    /I:[[:space:]]/ { val=$2; gsub(/[^0-9\.\-]/,"",val); I=I?I:val }
    /TP:[[:space:]]/ { val=$2; gsub(/[^0-9\.\-]/,"",val); TP=TP?TP:val }
    /LRA:[[:space:]]/ { val=$2; gsub(/[^0-9\.\-]/,"",val); LRA=LRA?LRA:val }
    /Threshold:[[:space:]]/ { val=$2; gsub(/[^0-9\.\-]/,"",val); TH=TH?TH:val }
    /Offset:[[:space:]]/ { val=$2; gsub(/[^0-9\.\-]/,"",val); OF=OF?OF:val }
    END{
      if(I==""||TP==""||LRA==""||TH==""||OF=="") exit 1;
      print I,TP,LRA,TH,OF
    }'
}

prompt_read() { printf '%s' "$1" >"$TTY_DEV"; IFS= read -r REPLY <"$TTY_DEV"; }

interactive_prompts() {
  printf '%s\n' "Select loudness target (TP = −1.0 dBTP):
  1) −18 LUFS (recommended)
  2) −16 LUFS" >"$TTY_DEV"
  prompt_read "Enter 1-2 (default 1): "
  case "${REPLY:-1}" in 1) TARGET_I="-18" ;; 2) TARGET_I="-16" ;; *) TARGET_I="-18" ;; esac

  printf '%s\n' "Choose output mode:
  1) wav
  2) mp3
  3) both (wav+mp3)
  4) flac
  5) wav+flac
  6) all (wav+mp3+flac)" >"$TTY_DEV"
  prompt_read "Enter 1-6 (default 3): "
  case "${REPLY:-3}" in
    1) OUTMODE="wav" ;;
    2) OUTMODE="mp3" ;;
    3) OUTMODE="both" ;;
    4) OUTMODE="flac" ;;
    5) OUTMODE="wav+flac" ;;
    6) OUTMODE="all" ;;
    *) OUTMODE="both" ;;
  esac

  if [[ "${OUTMODE}" == "mp3" || "${OUTMODE}" == "both" || "${OUTMODE}" == "all" ]]; then
    printf '%s\n' "MP3 bitrate:
    1) 128k
    2) 160k (recommended)
    3) 192k" >"$TTY_DEV"
    prompt_read "Enter 1-3 (default 2): "
    case "${REPLY:-2}" in
      1) MP3_BITRATE="128k" ;;
      2) MP3_BITRATE="160k" ;;
      3) MP3_BITRATE="192k" ;;
      *) MP3_BITRATE="160k" ;;
    esac
  fi

  printf '%s\n' "Sample rate:
  1) 44100 Hz (default)
  2) 48000 Hz" >"$TTY_DEV"
  prompt_read "Enter 1-2 (default 1): "
  case "${REPLY:-1}" in 1) SAMPLE_RATE="44100" ;; 2) SAMPLE_RATE="48000" ;; *) SAMPLE_RATE="44100" ;; esac

  {
    echo ""
    echo "Selections:"
    printf "  Target:  %3s LUFS (TP −1 dBTP)\n" "${TARGET_I}"
    printf "  Mode:    %s\n" "${OUTMODE}"
    if [[ "${OUTMODE}" == "mp3" || "${OUTMODE}" == "both" || "${OUTMODE}" == "all" ]]; then
      printf "  MP3:     %s\n" "${MP3_BITRATE}"
    fi
    printf "  Sample:  %s Hz\n" "${SAMPLE_RATE}"
  } >"$TTY_DEV"

  prompt_read "Proceed? [Y/n]: "
  case "${REPLY:-Y}" in Y|y|"") : ;; *) printf '%s\n' "Aborted." >"$TTY_DEV"; exit 1 ;; esac
}

# -------------------- CLI flags --------------------
while [[ $# -gt 0 ]]; do
  case "$1" in
    --no-prompt) PROMPT=0; shift ;;
    -t|--target) TARGET_I="$2"; shift 2 ;;
    -m|--mode) OUTMODE="$2"; shift 2 ;;
    -b|--bitrate) MP3_BITRATE="$2"; shift 2 ;;
    -s|--samplerate) SAMPLE_RATE="$2"; shift 2 ;;
    --flac-level) FLAC_LEVEL="$2"; shift 2 ;;
    -l|--log) LOG="$2"; shift 2 ;;
    -q|--quiet) QUIET=1; shift ;;
    -n|--dry-run) DRY_RUN=1; shift ;;
    -h|--help)
      cat <<'HLP' >"$TTY_DEV"
WaxOff — Final Mix Loudness Leveler
Usage: waxoff [options] <files...>

Options:
  --no-prompt             Non-interactive (use flags/env)
  -t, --target <LUFS>     -18 (default) | -16
  -m, --mode <mode>       wav | mp3 | both | flac | wav+flac | all   (default: both)
  -b, --bitrate <rate>    128k | 160k | 192k (MP3; default 160k)
  -s, --samplerate <hz>   44100 | 48000 (default 44100)
      --flac-level <N>    0..12 (default 8)
  -l, --log <path>        Log file path (default ~/Library/Logs/waxoff_cli.log)
  -q, --quiet             Reduce console output
  -n, --dry-run           Show plan only; no writes
  -h, --help              Show this help
HLP
      exit 0 ;;
    --) shift; break ;;
    -*) die "Unknown option: $1" ;;
    *) break ;;
  esac
done

[[ $# -lt 1 ]] && { err "No input files given. Try: waxoff -h"; exit 1; }

# -------------------- Preflight --------------------
need ffmpeg
case "$TARGET_I" in -18|-16) ;; *) die "TARGET_I must be -18 or -16";; esac
case "$SAMPLE_RATE" in 44100|48000) ;; *) die "SAMPLE_RATE must be 44100 or 48000";; esac
case "$OUTMODE" in wav|mp3|both|flac|wav+flac|all) ;; *) die "OUTMODE invalid: $OUTMODE";; esac
case "$MP3_BITRATE" in 128k|160k|192k) ;; *) die "MP3_BITRATE must be 128k|160k|192k";; esac
[[ "$FLAC_LEVEL" =~ ^[0-9]+$ ]] || die "FLAC_LEVEL must be 0..12"
test "$FLAC_LEVEL" -ge 0 -a "$FLAC_LEVEL" -le 12 || die "FLAC_LEVEL must be 0..12"

if [[ "${PROMPT}" = "1" ]]; then interactive_prompts; fi

# -------------------- Analysis --------------------
analyze_file() {
  local in="$1"
  local I_m TP_m LRA_m TH_m OF_m
  # Pass 1: JSON first
  local p1
  p1="$(ffmpeg -hide_banner -nostats -nostdin -y -i "$in" \
    -filter_complex "[0:a]loudnorm=I=${TARGET_I}:TP=${TARGET_TP}:LRA=11:print_format=json" \
    -f null - 2>&1)"
  if read -r I_m TP_m LRA_m TH_m OF_m < <(printf '%s\n' "$p1" | parse_json_loudnorm); then
    printf '%s\n' "$I_m $TP_m $LRA_m $TH_m $OF_m"
    return 0
  fi
  # Summary fallback
  local p1s
  p1s="$(ffmpeg -hide_banner -nostats -nostdin -y -i "$in" \
    -filter_complex "[0:a]loudnorm=I=${TARGET_I}:TP=${TARGET_TP}:LRA=11:print_format=summary" \
    -f null - 2>&1)"
  if read -r I_m TP_m LRA_m TH_m OF_m < <(printf '%s\n' "$p1s" | parse_summary_loudnorm); then
    printf '%s\n' "$I_m $TP_m $LRA_m $TH_m $OF_m"
    return 0
  fi
  return 1
}

# -------------------- Rendering helpers --------------------
render_with_fallbacks() {
  # $1 final_path, $2 fmt, $3 filterchain, $4... ffmpeg extra codec args
  local final="$1"; shift
  local fmt="$1"; shift
  local chain="$1"; shift

  # Try with soxr
  if atomic_write "$final" "$fmt" -- -i "$INFILE" -map 0:a:0 -vn -filter:a "${chain},aresample=${SAMPLE_RATE}:resampler=soxr" "$@" -ar "${SAMPLE_RATE}" -dn -nostdin; then
    return 0
  fi
  # Retry without specifying resampler (uses default)
  if atomic_write "$final" "$fmt" -- -i "$INFILE" -map 0:a:0 -vn -filter:a "${chain},aresample=${SAMPLE_RATE}" "$@" -ar "${SAMPLE_RATE}" -dn -nostdin; then
    warn "Resampler fallback succeeded for: ${final}"
    return 0
  fi
  return 1
}

# -------------------- Main loop --------------------
ok=0; fail=0

for INFILE in "$@"; do
  [[ -f "$INFILE" ]] || { warn "Skip (missing): $INFILE"; fail=$((fail+1)); continue; }

  say "Analyze: $INFILE"
  if ANALYSIS="$(analyze_file "$INFILE")"; then
    read -r I_m TP_m LRA_m TH_m OF_m <<<"$ANALYSIS"
    say "Measured: I=${I_m} LUFS, TP=${TP_m} dBTP, LRA=${LRA_m}"
    LOUD2="loudnorm=I=${TARGET_I}:TP=${TARGET_TP}:LRA=11:measured_I=${I_m}:measured_TP=${TP_m}:measured_LRA=${LRA_m}:measured_thresh=${TH_m}:offset=${OF_m}:linear=true:print_format=summary"
  else
    warn "Pass-1 parse failed; using single-pass loudnorm."
    LOUD2="loudnorm=I=${TARGET_I}:TP=${TARGET_TP}:LRA=11:linear=true:print_format=summary"
  fi

  DIR="$(cd "$(dirname "$INFILE")" && pwd -P)"
  BASE="$(basename "$INFILE")"
  STEM="${BASE%.*}"

  OUT_WAV="${DIR}/${STEM}-lvl${TARGET_I}LUFS.wav"
  OUT_MP3="${DIR}/${STEM}-lvl${TARGET_I}LUFS.mp3"
  OUT_FLAC="${DIR}/${STEM}-lvl${TARGET_I}LUFS.flac"

  # Render plan
  want_wav=0; want_mp3=0; want_flac=0
  case "$OUTMODE" in
    wav) want_wav=1 ;;
    mp3) want_mp3=1 ;;
    both) want_wav=1; want_mp3=1 ;;
    flac) want_flac=1 ;;
    wav+flac) want_wav=1; want_flac=1 ;;
    all) want_wav=1; want_mp3=1; want_flac=1 ;;
  esac

  out_ok=0; out_need=0

  if [[ $want_wav -eq 1 ]]; then
    out_need=$((out_need+1))
    say "Render WAV: ${OUT_WAV} @ ${SAMPLE_RATE} Hz"
    if render_with_fallbacks "$OUT_WAV" wav "$LOUD2" -c:a pcm_s24le; then
      out_ok=$((out_ok+1))
    else
      err "WAV failed for: ${INFILE}"
    fi
  fi

  if [[ $want_mp3 -eq 1 ]]; then
    out_need=$((out_need+1))
    say "Render MP3: ${OUT_MP3} (${MP3_BITRATE}) @ ${SAMPLE_RATE} Hz"
    if render_with_fallbacks "$OUT_MP3" mp3 "$LOUD2" -c:a libmp3lame -b:a "${MP3_BITRATE}"; then
      out_ok=$((out_ok+1))
    else
      err "MP3 failed for: ${INFILE}"
    fi
  fi

  if [[ $want_flac -eq 1 ]]; then
    out_need=$((out_need+1))
    say "Render FLAC: ${OUT_FLAC} (level ${FLAC_LEVEL}) @ ${SAMPLE_RATE} Hz"
    # First attempt with requested compression level
    if render_with_fallbacks "$OUT_FLAC" flac "$LOUD2" -c:a flac -compression_level "${FLAC_LEVEL}"; then
      out_ok=$((out_ok+1))
    else
      # Fallback: try default compression level (omit flag)
      warn "FLAC retry with default compression: ${OUT_FLAC}"
      if render_with_fallbacks "$OUT_FLAC" flac "$LOUD2" -c:a flac; then
        out_ok=$((out_ok+1))
      else
        err "FLAC failed for: ${INFILE}"
      fi
    fi
  fi

  if [[ $out_ok -eq $out_need && $out_need -gt 0 ]]; then
    say "OK: ${INFILE}"
    ok=$((ok+1))
  elif [[ $out_ok -gt 0 ]]; then
    warn "PARTIAL OK: ${INFILE}  (${out_ok}/${out_need} outputs)"
    fail=$((fail+1))
  else
    err "FAILED: ${INFILE}"
    fail=$((fail+1))
  fi
done

printf 'Result: files OK=%d, failed=%d\n' "$ok" "$fail" >"$TTY_DEV"
log "Result: files OK=${ok}, failed=${fail}"
[[ $fail -gt 0 ]] && exit 2 || exit 0
