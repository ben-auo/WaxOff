#!/usr/bin/env bash
# WaxOff — Interactive CLI Stereo Podcast Leveler (WAV/MP3/FLAC)
# VERSION v1.3 — with progress and macOS file picker

set -u
set +e
IFS=$'\n\t'

VERSION="${VERSION:-v1.3}"
APP_TITLE="WaxOff ${VERSION} — Interactive CLI Leveler"

PROMPT="${PROMPT:-1}"
TARGET_I="${TARGET_I:--18}"
TARGET_TP="${TARGET_TP:--1.0}"
TARGET_LRA="${TARGET_LRA:-11}"
OUTMODE="${OUTMODE:-both}"      # wav | mp3 | both | flac | wav+flac | all
MP3_BITRATE="${MP3_BITRATE:-160k}"
MP3_CODEC="${MP3_CODEC:-libmp3lame}"
SAMPLE_RATE="${SAMPLE_RATE:-44100}"
FLAC_LEVEL="${FLAC_LEVEL:-8}"
LOG_FILE="${LOG_FILE:-${HOME}/Library/Logs/waxoff_cli.log}"

export PATH="/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:$PATH"
FFMPEG="${FFMPEG:-$(command -v /opt/homebrew/bin/ffmpeg || command -v ffmpeg || true)}"

usage() { cat <<EOF
${APP_TITLE}

Usage: waxoff [options] <file>...

Options:
  -t, --target <LUFS>      -18 (default) or -16
  -m, --mode <mode>        wav | mp3 | both | flac | wav+flac | all   (default: both)
  -b, --bitrate <rate>     128k | 160k (default) | 192k  (for MP3)
  -s, --samplerate <hz>    44100 (default) or 48000
  --flac-level <N>         0..12 compression (default: 8)
  -l, --log <path>         Log file path
  --no-prompt              Run without interactive questions
  -q, --quiet              Less verbose console output
  -n, --dry-run            Show what would happen; no outputs written
  -h, --help               Show this help and exit
EOF
}

QUIET=0; DRYRUN=0; args=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    -t|--target)      TARGET_I="$2"; shift 2 ;;
    -m|--mode)        OUTMODE="$2"; shift 2 ;;
    -b|--bitrate)     MP3_BITRATE="$2"; shift 2 ;;
    -s|--samplerate)  SAMPLE_RATE="$2"; shift 2 ;;
    --flac-level)     FLAC_LEVEL="$2"; shift 2 ;;
    -l|--log)         LOG_FILE="$2"; shift 2 ;;
    --no-prompt)      PROMPT="0"; shift ;;
    -q|--quiet)       QUIET=1; shift ;;
    -n|--dry-run)     DRYRUN=1; shift ;;
    -h|--help)        usage; exit 0 ;;
    --)               shift; break ;;
    -*) echo "Unknown option: $1" >&2; usage; exit 2 ;;
    *) args+=("$1"); shift ;;
  esac
done
[[ $# -gt 0 ]] && args+=("$@")

is_int() { [[ "$1" =~ ^-?[0-9]+$ ]]; }
is_choice() { local v="$1"; shift; for c in "$@"; do [[ "$v" == "$c" ]] && return 0; done; return 1; }

# ---- macOS file picker (only when interactive & no args) ----
pick_files_macos() {
  /usr/bin/osascript <<'OSA' 2>/dev/null
set fp to choose file with prompt "Select one or more audio files for WaxOff:" with multiple selections allowed
set out to ""
repeat with f in fp
  set out to out & POSIX path of f & "\n"
end repeat
return out
OSA
}

prompt_target() {
  echo "Select loudness target (TP = −1.0 dBTP):"
  echo "  1) −18 LUFS (recommended)"
  echo "  2) −16 LUFS"
  read -r -p "Enter 1-2 (default 1): " a
  case "${a:-1}" in 1) TARGET_I="-18" ;; 2) TARGET_I="-16" ;; *) TARGET_I="-18" ;; esac
}
prompt_mode() {
  echo "Choose output mode:"
  echo "  1) wav"
  echo "  2) mp3"
  echo "  3) both (wav+mp3)"
  echo "  4) flac"
  echo "  5) wav+flac"
  echo "  6) all (wav+mp3+flac)"
  read -r -p "Enter 1-6 (default 3): " a
  case "${a:-3}" in
    1) OUTMODE="wav" ;; 2) OUTMODE="mp3" ;; 3) OUTMODE="both" ;;
    4) OUTMODE="flac" ;; 5) OUTMODE="wav+flac" ;; 6) OUTMODE="all" ;;
    *) OUTMODE="both" ;;
  esac
}
prompt_mp3() {
  case "$OUTMODE" in mp3|both|all)
    echo "MP3 bitrate:"
    echo "  1) 128k"
    echo "  2) 160k (recommended)"
    echo "  3) 192k"
    read -r -p "Enter 1-3 (default 2): " a
    case "${a:-2}" in 1) MP3_BITRATE="128k" ;; 2) MP3_BITRATE="160k" ;; 3) MP3_BITRATE="192k" ;; *) MP3_BITRATE="160k" ;; esac
  esac
}
prompt_flac() {
  case "$OUTMODE" in flac|wav+flac|all)
    read -r -p "FLAC compression level 0..12 (default 8): " a
    if is_int "${a:-8}" && (( ${a:-8} >= 0 && ${a:-8} <= 12 )); then FLAC_LEVEL="${a:-8}"; else FLAC_LEVEL="8"; fi
  esac
}
prompt_sr() {
  echo "Sample rate:"
  echo "  1) 44100 Hz (default)"
  echo "  2) 48000 Hz"
  read -r -p "Enter 1-2 (default 1): " a
  case "${a:-1}" in 1) SAMPLE_RATE="44100" ;; 2) SAMPLE_RATE="48000" ;; *) SAMPLE_RATE="44100" ;; esac
}
confirm() {
  echo
  echo "Selections:"
  echo "  Target:  ${TARGET_I} LUFS (TP −1 dBTP)"
  echo "  Mode:    ${OUTMODE}"
  [[ "$OUTMODE" =~ ^(mp3|both|all)$ ]] && echo "  MP3:     ${MP3_BITRATE}"
  [[ "$OUTMODE" =~ ^(flac|wav\+flac|all)$ ]] && echo "  FLAC:    level ${FLAC_LEVEL}"
  echo "  Sample:  ${SAMPLE_RATE} Hz"
  read -r -p "Proceed? [Y/n]: " yn; case "${yn:-Y}" in Y|y) : ;; *) echo "Cancelled."; exit 0 ;; esac
}

# Offer picker if no args
if [[ ${#args[@]} -lt 1 && "${PROMPT}" == "1" ]]; then
  picks="$(pick_files_macos || true)"
  if [[ -n "${picks:-}" ]]; then
    while IFS= read -r line; do
      [[ -n "$line" ]] && args+=("$line")
    done <<< "$picks"
  fi
fi

if [[ "${PROMPT}" == "1" ]]; then
  prompt_target; prompt_mode; prompt_mp3; prompt_flac; prompt_sr; confirm
fi

if [[ ${#args[@]} -lt 1 ]]; then echo "No input files."; exit 2; fi
if ! is_choice "$TARGET_I" "-18" "-16"; then echo "Invalid target: $TARGET_I"; exit 2; fi
if ! is_choice "$OUTMODE" "wav" "mp3" "both" "flac" "wav+flac" "all"; then echo "Invalid mode: $OUTMODE"; exit 2; fi
case "$MP3_BITRATE" in 128k|160k|192k) ;; *) echo "Invalid MP3 bitrate"; exit 2 ;; esac
case "$SAMPLE_RATE" in 44100|48000) ;; *) echo "Invalid samplerate"; exit 2 ;; esac
if ! is_int "$FLAC_LEVEL" || (( FLAC_LEVEL < 0 || FLAC_LEVEL > 12 )); then echo "Invalid flac level"; exit 2; fi

if [[ -z "${FFMPEG:-}" || ! -x "$FFMPEG" ]]; then
  echo "FFmpeg not found. Install with: brew install ffmpeg" >&2
  exit 2
}

# ---- Logging (tee to console + file) ----
mkdir -p "$(dirname "$LOG_FILE")" 2>/dev/null || true
exec > >(tee -a "$LOG_FILE") 2>&1
echo "======== $(date '+%Y-%m-%d %H:%M:%S') — Run start ========"
echo "Script: ${APP_TITLE}"
echo "PATH=$PATH"
echo "Args: ${args[*]}"
$FFMPEG -version 2>/dev/null | head -n1 || true
echo "Selections: target=${TARGET_I} LUFS | mode=${OUTMODE} | mp3=${MP3_BITRATE} | flac_level=${FLAC_LEVEL} | sr=${SAMPLE_RATE}"

# ---- Helpers ----
hidden_tmp() { local dir="$1" base="$2" ext="$3"; echo "${dir}/.${base}.part.$$.$RANDOM.${ext}"; }
extract_json_num() { local f="$1" key="$2"; LC_ALL=C sed -nE "s/.*\"${key}\"[[:space:]]*:[[:space:]]*([-+]?([0-9]*\.)?[0-9]+).*/\1/p" "$f" | head -n1; }
spotcheck_file() {
  local F="$1" OUT="$2" J
  J="$(mktemp -t waxoff_sc.XXXXXX.json 2>/dev/null || echo "/tmp/waxoff_sc.$RANDOM.json")"
  "$FFMPEG" -hide_banner -nostats -y -i "$F" \
    -af "loudnorm=I=${TARGET_I}:TP=${TARGET_TP}:LRA=${TARGET_LRA}:print_format=json" \
    -f null - 2> "$J"
  if [[ $? -ne 0 ]]; then
    echo "I=n/a TP=n/a" > "$OUT"
  else
    local fi tp
    fi="$(extract_json_num "$J" input_i)"
    tp="$(extract_json_num "$J" input_tp)"
    echo "I=${fi:-n/a} TP=${tp:-n/a}" > "$OUT"
  fi
  rm -f "$J" 2>/dev/null || true
}

# ---- Progress helpers ----
TTY_OUT="/dev/tty"; [ -w "$TTY_OUT" ] || TTY_OUT="/dev/null"
progress_draw() {  # $1=label  $2=pct (0..100)
  local label="$1" pct="$2" width=28 fill pad
  (( pct < 0 )) && pct=0; (( pct > 100 )) && pct=100
  fill=$(( (pct*width)/100 ))
  pad=$(( width - fill ))
  printf "\r%-12s [" "$label" >"$TTY_OUT"
  printf "%${fill}s" "" | tr ' ' '#' >"$TTY_OUT"
  printf "%${pad}s" ""  >"$TTY_OUT"
  printf "] %3d%%" "$pct" >"$TTY_OUT"
}
ffprobe_duration_s() {
  if ! command -v ffprobe >/dev/null 2>&1; then echo 0; return; fi
  local dur
  dur="$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$1" 2>/dev/null | head -n1)"
  [ -n "$dur" ] && echo "$dur" || echo 0
}
ffmpeg_with_progress() {
  local dur_s="$1" label="$2"; shift 2
  local pipe; pipe="$(mktemp -u)"; mkfifo "$pipe"
  (
    local total_us cur_us pct k v
    total_us=$(awk -v d="$dur_s" 'BEGIN{printf "%.0f", d*1000000}'); [ -z "$total_us" ] && total_us=1
    while IFS='=' read -r k v; do
      case "$k" in
        out_time_us) cur_us="${v%.*}";;
        out_time_ms) cur_us=$(( ${v%.*} * 1000 ));;
        progress) [ "$v" = "end" ] && break; continue;;
        *) continue;;
      esac
      [ -z "$cur_us" ] && cur_us=0
      pct=$(( cur_us * 100 / (total_us>0?total_us:1) ))
      (( pct>100 )) && pct=100
      progress_draw "$label" "$pct"
    done <"$pipe"
    progress_draw "$label" 100; printf "\n" >"$TTY_OUT"
  ) &
  local reader_pid=$!
  "$FFMPEG" -nostdin -hide_banner -loglevel error -stats_period 0.5 -progress "$pipe" "$@" 2>/dev/null
  local rc=$?
  kill "$reader_pid" >/dev/null 2>&1 || true
  rm -f "$pipe"
  return $rc
}

# ---- Main loop ----
TEMP_FILES=(); trap 'for f in "${TEMP_FILES[@]:-}"; do [[ -e "$f" ]] && rm -f "$f"; done' EXIT INT TERM

TOTAL=${#args[@]}; INDEX=0; OKC=0; FAILED=0; SKIPPED=0
[[ $QUIET -eq 0 ]] && echo "${APP_TITLE}" && echo "Mode=${OUTMODE}  Target=${TARGET_I} LUFS (TP −1 dBTP)  MP3=${MP3_BITRATE}  FLAC=${FLAC_LEVEL}  SR=${SAMPLE_RATE}"

for IN in "${args[@]}"; do
  INDEX=$((INDEX+1))
  if [[ ! -f "$IN" ]]; then echo "Skip (not a file): $IN"; SKIPPED=$((SKIPPED+1)); continue; fi

  BASE="$(basename "$IN")"; SRC_DIR="$(cd "$(dirname "$IN")" && pwd -P)"; OUT_DIR="$SRC_DIR"
  if [[ ! -w "$OUT_DIR" ]]; then echo "Skip (not writable): $OUT_DIR for ${BASE}"; SKIPPED=$((SKIPPED+1)); continue; fi

  STEM="${BASE%.*}"
  STEM_TAG="${STEM}-lev-${TARGET_I}LUFS"

  WAV_OUT="${OUT_DIR}/${STEM_TAG}.wav"
  MP3_OUT="${OUT_DIR}/${STEM_TAG}.mp3"
  FLAC_OUT="${OUT_DIR}/${STEM_TAG}.flac"

  TMP_WAV="$(hidden_tmp "$OUT_DIR" "$STEM_TAG" "wav")"; TEMP_FILES+=("$TMP_WAV")
  TMP_MP3="$(hidden_tmp "$OUT_DIR" "$STEM_TAG" "mp3")"
  TMP_FLAC="$(hidden_tmp "$OUT_DIR" "$STEM_TAG" "flac")"

  echo "--> (${INDEX}/${TOTAL}) $IN"
  if [[ $DRYRUN -eq 1 ]]; then
    echo "[dry-run] would render to: $WAV_OUT $MP3_OUT $FLAC_OUT"
    OKC=$((OKC+1)); continue
  fi

  # Pass 1 — measure only
  PASS1_JSON="$(mktemp -t waxoff_pass1.XXXXXX.json 2>/dev/null || echo "/tmp/waxoff_pass1.$RANDOM.json")"
  "$FFMPEG" -hide_banner -nostats -y -i "$IN" \
    -af "loudnorm=I=${TARGET_I}:TP=${TARGET_TP}:LRA=${TARGET_LRA}:print_format=json" \
    -f null - 2> "$PASS1_JSON"
  P1_RC=$?
  MEAS_I="$(extract_json_num "$PASS1_JSON" input_i)"
  MEAS_TP="$(extract_json_num "$PASS1_JSON" input_tp)"
  MEAS_LRA="$(extract_json_num "$PASS1_JSON" input_lra)"
  MEAS_THRESH="$(extract_json_num "$PASS1_JSON" input_thresh)"
  MEAS_OFFSET="$(extract_json_num "$PASS1_JSON" target_offset)"
  rm -f "$PASS1_JSON" 2>/dev/null || true
  HAVE_MEAS=0; [[ $P1_RC -eq 0 && -n "${MEAS_I:-}" && -n "${MEAS_TP:-}" && -n "${MEAS_LRA:-}" && -n "${MEAS_THRESH:-}" && -n "${MEAS_OFFSET:-}" ]] && HAVE_MEAS=1

  DUR_RENDER="$(ffprobe_duration_s "$IN")"

  # WAV render with progress
  if [[ $HAVE_MEAS -eq 1 ]]; then
    if ! ffmpeg_with_progress "$DUR_RENDER" "render" \
         -y -i "$IN" \
         -af "loudnorm=I=${TARGET_I}:TP=${TARGET_TP}:LRA=${TARGET_LRA}:measured_I=${MEAS_I}:measured_TP=${MEAS_TP}:measured_LRA=${MEAS_LRA}:measured_thresh=${MEAS_THRESH}:offset=${MEAS_OFFSET}:linear=true:print_format=summary" \
         -ar "$SAMPLE_RATE" -c:a pcm_s24le -f wav "$TMP_WAV"
    then
      echo "!! WAV render FAILED for: $BASE"; FAILED=$((FAILED+1)); continue
    fi
  else
    if ! ffmpeg_with_progress "$DUR_RENDER" "render" \
         -y -i "$IN" \
         -af "loudnorm=I=${TARGET_I}:TP=${TARGET_TP}:LRA=${TARGET_LRA}:linear=true:print_format=summary" \
         -ar "$SAMPLE_RATE" -c:a pcm_s24le -f wav "$TMP_WAV"
    then
      echo "!! WAV render FAILED for: $BASE"; FAILED=$((FAILED+1)); continue
    fi
  fi

  want_wav=0; want_mp3=0; want_flac=0
  [[ "$OUTMODE" == "wav" || "$OUTMODE" == "both" || "$OUTMODE" == "wav+flac" || "$OUTMODE" == "all" ]] && want_wav=1
  [[ "$OUTMODE" == "mp3" || "$OUTMODE" == "both" || "$OUTMODE" == "all" ]] && want_mp3=1
  [[ "$OUTMODE" == "flac" || "$OUTMODE" == "wav+flac" || "$OUTMODE" == "all" ]] && want_flac=1

  # Reveal WAV if requested
  if [[ $want_wav -eq 1 ]]; then
    mv -f "$TMP_WAV" "$WAV_OUT"
    for i in "${!TEMP_FILES[@]}"; do [[ "${TEMP_FILES[$i]}" = "$TMP_WAV" ]] && unset 'TEMP_FILES[i]'; done
  fi

  # MP3 encode with progress
  if [[ $want_mp3 -eq 1 ]]; then
    SRC_FOR_MP3="$TMP_WAV"; [[ -f "$WAV_OUT" ]] && SRC_FOR_MP3="$WAV_OUT"
    TEMP_FILES+=("$TMP_MP3")
    ENC_DUR="$(ffprobe_duration_s "${WAV_OUT:-$TMP_WAV}")"
    if ffmpeg_with_progress "$ENC_DUR" "mp3" \
         -y -i "$SRC_FOR_MP3" -c:a "$MP3_CODEC" -b:a "$MP3_BITRATE" -ar "$SAMPLE_RATE" -ac 2 -f mp3 "$TMP_MP3"
    then
      mv -f "$TMP_MP3" "$MP3_OUT"
      for i in "${!TEMP_FILES[@]}"; do [[ "${TEMP_FILES[$i]}" = "$TMP_MP3" ]] && unset 'TEMP_FILES[i]'; done
    else
      echo "!! MP3 encode FAILED for: $BASE"; FAILED=$((FAILED+1))
    fi
  fi

  # FLAC encode with progress
  if [[ $want_flac -eq 1 ]]; then
    SRC_FOR_FLAC="$TMP_WAV"; [[ -f "$WAV_OUT" ]] && SRC_FOR_FLAC="$WAV_OUT"
    TEMP_FILES+=("$TMP_FLAC")
    ENC_DUR="$(ffprobe_duration_s "${WAV_OUT:-$TMP_WAV}")"
    if ffmpeg_with_progress "$ENC_DUR" "flac" \
         -y -i "$SRC_FOR_FLAC" -c:a flac -compression_level "$FLAC_LEVEL" -ar "$SAMPLE_RATE" -f flac "$TMP_FLAC"
    then
      mv -f "$TMP_FLAC" "$FLAC_OUT"
      for i in "${!TEMP_FILES[@]}"; do [[ "${TEMP_FILES[$i]}" = "$TMP_FLAC" ]] && unset 'TEMP_FILES[i]'; done
    else
      echo "!! FLAC encode FAILED for: $BASE"; FAILED=$((FAILED+1))
    fi
  fi

  # Spot-check
  SC_TXT="$(mktemp -t waxoff_sc.XXXXXX.txt 2>/dev/null || echo "/tmp/waxoff_sc.$RANDOM.txt")"
  if [[ -f "$WAV_OUT" ]]; then
    spotcheck_file "$WAV_OUT" "$SC_TXT"
  else
    spotcheck_file "$TMP_WAV" "$SC_TXT"
  fi
  OUTS=()
  [[ $want_wav -eq 1 ]]  && OUTS+=("$(basename "$WAV_OUT")")
  [[ $want_mp3 -eq 1 ]] && OUTS+=("$(basename "$MP3_OUT")")
  [[ $want_flac -eq 1 ]] && OUTS+=("$(basename "$FLAC_OUT")")
  echo "✓ ${BASE} → ${OUTS[*]}  $(cat "$SC_TXT" 2>/dev/null || echo "")"
  rm -f "$SC_TXT" 2>/dev/null || true

  # If mp3/flac only, remove hidden WAV temp
  if [[ $want_wav -eq 0 && -f "$TMP_WAV" ]]; then
    rm -f "$TMP_WAV"
    for i in "${!TEMP_FILES[@]}"; do [[ "${TEMP_FILES[$i]}" = "$TMP_WAV" ]] && unset 'TEMP_FILES[i]'; done
  fi

  OKC=$((OKC+1))
done

[[ $QUIET -eq 0 ]] && echo "Summary: OK=${OKC}  Failed=${FAILED}  Skipped=${SKIPPED} | Version: ${VERSION}"
echo "======== $(date '+%Y-%m-%d %H:%M:%S') — Run end ========"
[[ $FAILED -gt 0 ]] && exit 1 || exit 0
