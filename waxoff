#!/usr/bin/env bash
# WaxOff — Interactive CLI Stereo Podcast Leveler (FLAC-enabled)
# VERSION v1.2
set -u
set +e
IFS=$'\n\t'

VERSION="${VERSION:-v1.2}"
APP_TITLE="WaxOff ${VERSION} — Interactive CLI Leveler"

# ---------------- Defaults ----------------
PROMPT="${PROMPT:-1}"                 # 1=ask questions; 0=non-interactive
TARGET_I="${TARGET_I:--18}"           # -18 (recommended) or -16
TARGET_TP="${TARGET_TP:--1.0}"
TARGET_LRA="${TARGET_LRA:-11}"
OUTMODE="${OUTMODE:-both}"            # wav | mp3 | both | flac | wav+flac | all
MP3_BITRATE="${MP3_BITRATE:-160k}"    # 128k|160k|192k
MP3_CODEC="${MP3_CODEC:-libmp3lame}"
SAMPLE_RATE="${SAMPLE_RATE:-44100}"   # 44100|48000
FLAC_LEVEL="${FLAC_LEVEL:-8}"         # 0..12
LOG_FILE="${LOG_FILE:-${HOME}/Library/Logs/waxoff_cli.log}"

# Tools
export PATH="/opt/homebrew/bin:/usr/local/bin:/usr/local/sbin:/usr/bin:/bin:/usr/sbin:/sbin:$PATH"
FFMPEG="${FFMPEG:-$(command -v /opt/homebrew/bin/ffmpeg || command -v ffmpeg || true)}"

# ---------------- Robust binds for set -u ----------------
: "${PROMPT:=1}"
: "${TARGET_I:=-18}"
: "${TARGET_TP:=-1.0}"
: "${TARGET_LRA:=11}"
: "${OUTMODE:=both}"
: "${MP3_BITRATE:=160k}"
: "${MP3_CODEC:=libmp3lame}"
: "${SAMPLE_RATE:=44100}"
: "${FLAC_LEVEL:=8}"
: "${LOG_FILE:=${HOME}/Library/Logs/waxoff_cli.log}"

# ---------------- Usage / args ----------------
usage() { cat <<EOF
${APP_TITLE}

Usage: waxoff [options] <file>...

Options:
  -t, --target <LUFS>      -18 (default) or -16
  -m, --mode <mode>        wav | mp3 | both | flac | wav+flac | all   (default: both)
  -b, --bitrate <rate>     128k | 160k (default) | 192k  (for MP3)
  -s, --samplerate <hz>    44100 (default) or 48000
  --flac-level <N>         0..12 compression (default: 8)
  -l, --log <path>         Log file path
  --no-prompt              Run without interactive questions
  -q, --quiet              Less verbose console output
  -n, --dry-run            Show what would happen; no outputs written
  -h, --help               Show this help and exit
EOF
}

QUIET=0; DRYRUN=0; args=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    -t|--target)      TARGET_I="$2"; shift 2 ;;
    -m|--mode)        OUTMODE="$2"; shift 2 ;;
    -b|--bitrate)     MP3_BITRATE="$2"; shift 2 ;;
    -s|--samplerate)  SAMPLE_RATE="$2"; shift 2 ;;
    --flac-level)     FLAC_LEVEL="$2"; shift 2 ;;
    -l|--log)         LOG_FILE="$2"; shift 2 ;;
    --no-prompt)      PROMPT="0"; shift ;;
    -q|--quiet)       QUIET=1; shift ;;
    -n|--dry-run)     DRYRUN=1; shift ;;
    -h|--help)        usage; exit 0 ;;
    --)               shift; break ;;
    -*) echo "Unknown option: $1" >&2; usage; exit 2 ;;
    *) args+=("$1"); shift ;;
  esac
done
[[ $# -gt 0 ]] && args+=("$@")

# ---------------- Helpers ----------------
is_int() { [[ "$1" =~ ^-?[0-9]+$ ]]; }
is_choice() { local v="$1"; shift; for c in "$@"; do [[ "$v" == "$c" ]] && return 0; done; return 1; }

hidden_tmp() { local dir="$1" base="$2" ext="$3"; echo "${dir}/.${base}.part.$$.$RANDOM.${ext}"; }
extract_json_num() { local f="$1" key="$2"; LC_ALL=C sed -nE "s/.*\"${key}\"[[:space:]]*:[[:space:]]*([-+]?([0-9]*\.)?[0-9]+).*/\1/p" "$f" | head -n1; }
spotcheck_file() {
  local F="$1" OUT="$2" J
  J="$(mktemp -t waxoff_sc.XXXXXX.json 2>/dev/null || echo "/tmp/waxoff_sc.$RANDOM.json")"
  "$FFMPEG" -hide_banner -nostats -y -i "$F" \
    -af "loudnorm=I=${TARGET_I}:TP=${TARGET_TP}:LRA=${TARGET_LRA}:print_format=json" \
    -f null - 2> "$J"
  if [[ $? -ne 0 ]]; then
    echo "I=n/a TP=n/a" > "$OUT"
  else
    local fi tp
    fi="$(extract_json_num "$J" input_i)"
    tp="$(extract_json_num "$J" input_tp)"
    echo "I=${fi:-n/a} TP=${tp:-n/a}" > "$OUT"
  fi
  rm -f "$J" 2>/dev/null || true
}

# macOS file picker (when no filenames given and PROMPT=1)
pick_files_macos() {
  /usr/bin/osascript <<'OSA' 2>/dev/null
set fp to choose file with prompt "Select one or more files for WaxOff:" with multiple selections allowed
set out to ""
repeat with f in fp
  set out to out & POSIX path of f & "\n"
end repeat
return out
OSA
}

# ---------------- Interactive prompts ----------------
prompt_target() {
  echo "Select loudness target (TP = −1.0 dBTP):"
  echo "  1) −18 LUFS (recommended)"
  echo "  2) −16 LUFS"
  read -r -p "Enter 1-2 (default 1): " a
  case "${a:-1}" in 1) TARGET_I="-18" ;; 2) TARGET_I="-16" ;; *) TARGET_I="-18" ;; esac
}
prompt_mode() {
  echo "Choose output mode:"
  echo "  1) wav"
  echo "  2) mp3"
  echo "  3) both (wav+mp3)"
  echo "  4) flac"
  echo "  5) wav+flac"
  echo "  6) all (wav+mp3+flac)"
  read -r -p "Enter 1-6 (default 3): " a
  case "${a:-3}" in
    1) OUTMODE="wav" ;; 2) OUTMODE="mp3" ;; 3) OUTMODE="both" ;;
    4) OUTMODE="flac" ;; 5) OUTMODE="wav+flac" ;; 6) OUTMODE="all" ;;
    *) OUTMODE="both" ;;
  esac
}
prompt_mp3() {
  case "$OUTMODE" in mp3|both|all)
    echo "MP3 bitrate:"
    echo "  1) 128k"
    echo "  2) 160k (recommended)"
    echo "  3) 192k"
    read -r -p "Enter 1-3 (default 2): " a
    case "${a:-2}" in 1) MP3_BITRATE="128k" ;; 2) MP3_BITRATE="160k" ;; 3) MP3_BITRATE="192k" ;; *) MP3_BITRATE="160k" ;; esac
  esac
}
prompt_flac() {
  case "$OUTMODE" in flac|wav+flac|all)
    read -r -p "FLAC compression level 0..12 (default 8): " a
    if is_int "${a:-8}" && (( ${a:-8} >= 0 && ${a:-8} <= 12 )); then FLAC_LEVEL="${a:-8}"; else FLAC_LEVEL="8"; fi
  esac
}
prompt_sr() {
  echo "Sample rate:"
  echo "  1) 44100 Hz (default)"
  echo "  2) 48000 Hz"
  read -r -p "Enter 1-2 (default 1): " a
  case "${a:-1}" in 1) SAMPLE_RATE="44100" ;; 2) SAMPLE_RATE="48000" ;; *) SAMPLE_RATE="44100" ;; esac
}
confirm() {
  echo
  echo "Selections:"
  echo "  Target:  ${TARGET_I} LUFS (TP −1 dBTP)"
  echo "  Mode:    ${OUTMODE}"
  [[ "$OUTMODE" =~ mp3|both|all ]] && echo "  MP3:     ${MP3_BITRATE}"
  [[ "$OUTMODE" =~ flac|wav\+flac|all ]] && echo "  FLAC:    level ${FLAC_LEVEL}"
  echo "  Sample:  ${SAMPLE_RATE} Hz"
  read -r -p "Proceed? [Y/n]: " yn; case "${yn:-Y}" in Y|y) : ;; *) echo "Cancelled."; exit 0 ;; esac
}

# ---------------- If no files provided, offer a picker ----------------
if [[ ${#args[@]} -lt 1 && "${PROMPT}" == "1" ]]; then
  picks="$(pick_files_macos || true)"
  if [[ -n "${picks:-}" ]]; then
    while IFS= read -r line; do
      [[ -n "$line" ]] && args+=("$line")
    done <<< "$picks"
  fi
fi

# ---------------- Validation ----------------
if [[ "${PROMPT}" == "1" ]]; then
  prompt_target; prompt_mode; prompt_mp3; prompt_flac; prompt_sr; confirm
fi

if [[ ${#args[@]} -lt 1 ]]; then
  echo "No input files selected. Tip: run 'waxoff *.wav' or start without args to pick files via dialog."
  exit 2
fi
if ! is_choice "$TARGET_I" "-18" "-16"; then echo "Invalid target: $TARGET_I"; exit 2; fi
if ! is_choice "$OUTMODE" "wav" "mp3" "both" "flac" "wav+flac" "all"; then echo "Invalid mode: $OUTMODE"; exit 2; fi
case "$MP3_BITRATE" in 128k|160k|192k) ;; *) echo "Invalid MP3 bitrate"; exit 2 ;; esac
case "$SAMPLE_RATE" in 44100|48000) ;; *) echo "Invalid samplerate"; exit 2 ;; esac
if ! is_int "$FLAC_LEVEL" || (( FLAC_LEVEL < 0 || FLAC_LEVEL > 12 )); then echo "Invalid flac level"; exit 2; fi

if [[ -z "${FFMPEG:-}" || ! -x "$FFMPEG" ]]; then
  echo "FFmpeg not found. Install with: brew install ffmpeg" >&2
  exit 2
fi

# ---------------- Logging (tee to console + file) ----------------
mkdir -p "$(dirname "$LOG_FILE")" 2>/dev/null || true
exec > >(tee -a "$LOG_FILE") 2>&1

echo "======== $(date '+%Y-%m-%d %H:%M:%S') — Run start ========"
echo "Script: ${APP_TITLE}"
echo "PATH=$PATH"
printf "Args (%d):\n" "${#args[@]}"
for a in "${args[@]}"; do echo "  - $a"; done
$FFMPEG -version 2>/dev/null | head -n1 || true
echo "Selections: target=${TARGET_I} LUFS | mode=${OUTMODE} | mp3=${MP3_BITRATE} | flac_level=${FLAC_LEVEL} | sr=${SAMPLE_RATE}"

# ---------------- Processing ----------------
TEMP_FILES=(); trap 'for f in "${TEMP_FILES[@]:-}"; do [[ -e "$f" ]] && rm -f "$f"; done' EXIT INT TERM

TOTAL=${#args[@]}; INDEX=0; OKC=0; FAILED=0; SKIPPED=0
echo "${APP_TITLE}"
echo "Mode=${OUTMODE}  Target=${TARGET_I} LUFS (TP −1 dBTP)  MP3=${MP3_BITRATE}  FLAC=${FLAC_LEVEL}  SR=${SAMPLE_RATE}"

for IN in "${args[@]}"; do
  INDEX=$((INDEX+1))
  if [[ ! -f "$IN" ]]; then echo "Skip (not a file): $IN"; SKIPPED=$((SKIPPED+1)); continue; fi

  BASE="$(basename "$IN")"
  SRC_DIR="$(cd "$(dirname "$IN")" && pwd -P)"
  OUT_DIR="$SRC_DIR"
  if [[ ! -w "$OUT_DIR" ]]; then echo "Skip (not writable): $OUT_DIR for ${BASE}"; SKIPPED=$((SKIPPED+1)); continue; fi

  STEM="${BASE%.*}"
  STEM_TAG="${STEM}-lev-${TARGET_I}LUFS"

  WAV_OUT="${OUT_DIR}/${STEM_TAG}.wav"
  MP3_OUT="${OUT_DIR}/${STEM_TAG}.mp3"
  FLAC_OUT="${OUT_DIR}/${STEM_TAG}.flac"

  TMP_WAV="$(hidden_tmp "$OUT_DIR" "$STEM_TAG" "wav")"; TEMP_FILES+=("$TMP_WAV")
  TMP_MP3="$(hidden_tmp "$OUT_DIR" "$STEM_TAG" "mp3")"
  TMP_FLAC="$(hidden_tmp "$OUT_DIR" "$STEM_TAG" "flac")"

  echo "--> (${INDEX}/${TOTAL}) $IN"
  if [[ $DRYRUN -eq 1 ]]; then
    outs=()
    case "$OUTMODE" in
      wav) outs+=("$WAV_OUT") ;;
      mp3) outs+=("$MP3_OUT") ;;
      both) outs+=("$WAV_OUT" "$MP3_OUT") ;;
      flac) outs+=("$FLAC_OUT") ;;
      wav+flac) outs+=("$WAV_OUT" "$FLAC_OUT") ;;
      all) outs+=("$WAV_OUT" "$MP3_OUT" "$FLAC_OUT") ;;
    esac
    echo "[dry-run] would render: ${outs[*]}"
    OKC=$((OKC+1)); continue
  fi

  # Pass 1 — measure only
  PASS1_JSON="$(mktemp -t waxoff_pass1.XXXXXX.json 2>/dev/null || echo "/tmp/waxoff_pass1.$RANDOM.json")"
  "$FFMPEG" -hide_banner -nostats -y -i "$IN" \
    -af "loudnorm=I=${TARGET_I}:TP=${TARGET_TP}:LRA=${TARGET_LRA}:print_format=json" \
    -f null - 2> "$PASS1_JSON"
  P1_RC=$?

  MEAS_I="$(extract_json_num "$PASS1_JSON" input_i)"
  MEAS_TP="$(extract_json_num "$PASS1_JSON" input_tp)"
  MEAS_LRA="$(extract_json_num "$PASS1_JSON" input_lra)"
  MEAS_THRESH="$(extract_json_num "$PASS1_JSON" input_thresh)"
  MEAS_OFFSET="$(extract_json_num "$PASS1_JSON" target_offset)"
  rm -f "$PASS1_JSON" 2>/dev/null || true
  HAVE_MEAS=0
  [[ $P1_RC -eq 0 && -n "${MEAS_I:-}" && -n "${MEAS_TP:-}" && -n "${MEAS_LRA:-}" && -n "${MEAS_THRESH:-}" && -n "${MEAS_OFFSET:-}" ]] && HAVE_MEAS=1

  # Pass 2 — render WAV to hidden temp (linear gain only)
  if [[ $HAVE_MEAS -eq 1 ]]; then
    "$FFMPEG" -hide_banner -nostats -y -i "$IN" \
      -af "loudnorm=I=${TARGET_I}:TP=${TARGET_TP}:LRA=${TARGET_LRA}:measured_I=${MEAS_I}:measured_TP=${MEAS_TP}:measured_LRA=${MEAS_LRA}:measured_thresh=${MEAS_THRESH}:offset=${MEAS_OFFSET}:linear=true:print_format=summary" \
      -ar "$SAMPLE_RATE" -c:a pcm_s24le -f wav "$TMP_WAV"
  else
    "$FFMPEG" -hide_banner -nostats -y -i "$IN" \
      -af "loudnorm=I=${TARGET_I}:TP=${TARGET_TP}:LRA=${TARGET_LRA}:linear=true:print_format=summary" \
      -ar "$SAMPLE_RATE" -c:a pcm_s24le -f wav "$TMP_WAV"
  fi

  if [[ ! -s "$TMP_WAV" ]]; then
    echo "!! WAV render FAILED for: $BASE"
    FAILED=$((FAILED+1))
    continue
  fi

  # Decide desired outputs
  want_wav=0; want_mp3=0; want_flac=0
  [[ "$OUTMODE" == "wav" || "$OUTMODE" == "both" || "$OUTMODE" == "wav+flac" || "$OUTMODE" == "all" ]] && want_wav=1
  [[ "$OUTMODE" == "mp3" || "$OUTMODE" == "both" || "$OUTMODE" == "all" ]] && want_mp3=1
  [[ "$OUTMODE" == "flac" || "$OUTMODE" == "wav+flac" || "$OUTMODE" == "all" ]] && want_flac=1

  # Reveal WAV atomically if requested
  if [[ $want_wav -eq 1 ]]; then
    mv -f "$TMP_WAV" "$WAV_OUT"
    for i in "${!TEMP_FILES[@]}"; do [[ "${TEMP_FILES[$i]}" = "$TMP_WAV" ]] && unset 'TEMP_FILES[i]'; done
  fi

  # MP3 encoding (from revealed WAV if exists, otherwise the hidden temp)
  if [[ $want_mp3 -eq 1 ]]; then
    SRC_FOR_MP3="$TMP_WAV"; [[ -f "$WAV_OUT" ]] && SRC_FOR_MP3="$WAV_OUT"
    TEMP_FILES+=("$TMP_MP3")
    "$FFMPEG" -hide_banner -nostats -y -i "$SRC_FOR_MP3" \
      -c:a "$MP3_CODEC" -b:a "$MP3_BITRATE" -ar "$SAMPLE_RATE" -ac 2 -f mp3 "$TMP_MP3"
    if [[ -s "$TMP_MP3" ]]; then
      mv -f "$TMP_MP3" "$MP3_OUT"
      for i in "${!TEMP_FILES[@]}"; do [[ "${TEMP_FILES[$i]}" = "$TMP_MP3" ]] && unset 'TEMP_FILES[i]'; done
    else
      echo "!! MP3 encode FAILED for: $BASE"
      FAILED=$((FAILED+1))
    fi
  fi

  # FLAC encoding
  if [[ $want_flac -eq 1 ]]; then
    SRC_FOR_FLAC="$TMP_WAV"; [[ -f "$WAV_OUT" ]] && SRC_FOR_FLAC="$WAV_OUT"
    TEMP_FILES+=("$TMP_FLAC")
    "$FFMPEG" -hide_banner -nostats -y -i "$SRC_FOR_FLAC" \
      -c:a flac -compression_level "$FLAC_LEVEL" -ar "$SAMPLE_RATE" -f flac "$TMP_FLAC"
    if [[ -s "$TMP_FLAC" ]]; then
      mv -f "$TMP_FLAC" "$FLAC_OUT"
      for i in "${!TEMP_FILES[@]}"; do [[ "${TEMP_FILES[$i]}" = "$TMP_FLAC" ]] && unset 'TEMP_FILES[i]'; done
    else
      echo "!! FLAC encode FAILED for: $BASE"
      FAILED=$((FAILED+1))
    fi
  fi

  # Spot-check (prefer revealed WAV if available)
  SC_TXT="$(mktemp -t waxoff_sc.XXXXXX.txt 2>/dev/null || echo "/tmp/waxoff_sc.$RANDOM.txt")"
  if [[ -f "$WAV_OUT" ]]; then
    spotcheck_file "$WAV_OUT" "$SC_TXT"
  else
    spotcheck_file "$TMP_WAV" "$SC_TXT"
  fi

  OUTS=()
  [[ $want_wav -eq 1 ]] && OUTS+=("$(basename "$WAV_OUT")")
  [[ $want_mp3 -eq 1 ]] && OUTS+=("$(basename "$MP3_OUT")")
  [[ $want_flac -eq 1 ]] && OUTS+=("$(basename "$FLAC_OUT")")
  echo "✓ ${BASE} → ${OUTS[*]}  $(cat "$SC_TXT" 2>/dev/null || echo "")"
  rm -f "$SC_TXT" 2>/dev/null || true

  # If mp3/flac-only, clean the hidden WAV temp now
  if [[ $want_wav -eq 0 && -f "$TMP_WAV" ]]; then
    rm -f "$TMP_WAV"
    for i in "${!TEMP_FILES[@]}"; do [[ "${TEMP_FILES[$i]}" = "$TMP_WAV" ]] && unset 'TEMP_FILES[i]'; done
  fi

  OKC=$((OKC+1))
done

echo "Summary: OK=${OKC}  Failed=${FAILED}  Skipped=${SKIPPED} | Version: ${VERSION}"
echo "======== $(date '+%Y-%m-%d %H:%M:%S') — Run end ========"
[[ $FAILED -gt 0 ]] && exit 1 || exit 0
